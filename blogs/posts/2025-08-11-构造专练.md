构造太菜了，多多练习涨涨脑子。

# [[POI 2013] GRA-Tower Defense Game](https://www.luogu.com.cn/problem/P3557)
一道水绿，一看是还以为攻击距离为 2 是指只能打到相距为 2 的点，画了一下样例以后发现不就是在一开始的基础上多走一步吗。

- 发现：或许在攻击距离为 1 的时候要好好考虑一下分配，可是当你发现攻击距离为 2 的话，随便怎么搞都一定不劣

大概口胡一下就是本来要选择的是 $u$，控制的点是集合 $v$，脑子里抽象一下一定是 1 ~ 3 的距离会摆放一个。  
但现在攻击距离为 2，每 2 个至少能控制 1 ~ 5 的距离，所以顺序随意摆放一定不劣。

AC code:
```
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10;
int n, m, k, cnt;
vector<int> G[N], ans;
bool vis[N];
void cover(int x) {
	for(int y : G[x]) {
		vis[y] = 1;
		for(int z : G[y])
			vis[z] = 1;
	}
}
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m >> k;
	for(int i = 1, u, v; i <= m; i ++) {
		cin >> u >> v;
		G[u].emplace_back(v), G[v].emplace_back(u);
	}
	for(int i = 1; i <= n; i ++) {
		if(!vis[i]) {
			vis[i] = true;
			cover(i);
			ans.emplace_back(i);
		}
	}
	cout << ans.size() << '\n';
	for(int it : ans) cout << it << ' ';
	return cout << '\n', 0;
}
```

# [树的重量](https://www.luogu.com.cn/problem/P1268)
神仙题，这道题让我知道了**画图找规律**的重要性。

一开始看到这么小的数据范围，想的竟然是枚举值域，真的唐。  
想了很久无果，果断看 TJ。  
看了以后：真的水。

- n = 2 的情况：显然 $G_{1, 2}$。
- n = 3 的情况：
  ![](https://cdn.luogu.com.cn/upload/pic/1522.png)
  一眼发现答案就是蓝色这段的长度，那么记这段长度为 $l$，则 $l = \frac{G_{1, 3} + G_{2, 3} - G_{1, 2}}{2}$
- n = 4 的情况：
  ![](https://cdn.luogu.com.cn/upload/pic/1523.png)
  这是一种情况，这一段的长度 $l = \frac{G_{1, 4} + G_{3, 4} - G_{3, 4}}{2}$，但是如果你把 4 看作在 1 和 2 上的话，算出来的 $l$ 就会是红色的那一段。
- n > 4 的情况：我们发现可以考虑去枚举当前加入的点 $i$ 所在段的位置 $j - 1, j$，然后通过前面发现的规律计算出最小值即可。

AC code:
```
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int n, G[N][N], ans;
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n;
	for(int i = 1; i < n; i ++)
		for(int j = i + 1; j <= n; j ++)
			cin >> G[i][j];
	ans = G[1][2];
	for(int i = 3, minv; i <= n; i ++) {
		minv = 0x3f3f3f3f;
		for(int j = 2; j < i; j ++) minv = min(minv, G[1][i] + G[j][i] - G[1][j] >> 1);
		ans += minv;
	}
	return cout << ans << '\n', 0;
}
```
# [【MX-X10-T3】[LSOT-4] 全国联赛？](https://www.luogu.com.cn/problem/P12007)
肯定被低估的一道绿题，在我看来至少都是蓝。

题意：给你个森林，让你用 n - m - 1 条边将其变成一棵树，并且树中任意 2 点的距离相加的和最小。

### 状态与转移

转换以后都有树了，那直接上树形 dp 呀。  
- 状态：$f_{root}$ 表示以 root 为根的最小答案，$g_{root}$ 表示以 root 为根每个点到 root 的距离和。
空有状态也不行，所以我们必须假设现在有一些东西，就比如合并 $u$ 和 $v$ 为根的 2 棵树，用 $w$ 来连接。
- 状态转移：
  $$f_{root} = f_u + f_v + g_u \times sz_v + g_v \times sz_u + sz_u \times sz_v \times w$$
先不忙考虑 $g$ 的转移，观察这个式子，你会发现对式子产生影响的只有 $g_u$，$g_v$，对于根的影响也只是它们，所以我们要尽可能减少 $g_u$ 和 $g_v$，那么 $u, v$ 分别选择 2 棵树的重心一定最优，故 $root$ 选择 $u$ 或者 $v$ 一定最优。

现在假设 $sz_u > sz_v$，则 $g$ 的状态转移：
$$g_{u'} = g_u + g_v + w \times sz_v$$  
$$g_{v'} = g_u + g_v + w \times sz_u$$

所以上面的一个式子就是 $g$ 的状态转移式。

一直转移直到只有 1 棵树即可。

### 初始化和细节

$g$ 的初始化就是一个很标准的换根 dp 初始化，直接 copy 一下即可。  
$w$ 按照从小到大的顺序进行添加，有一点启发式合并的味。

AC code:
```
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
const int N = 1e6 + 10, Mod = 1e9 + 7;
int n, m, sz[N], node[N], len;
LL w[N], g[N], tmp[N];
LL ans;
bool vis[N];
vector<pair<int, LL>> G[N];
array<LL, 2> u, v;
void dfs1(int u, int fa) {
	sz[u] = 1, vis[u] = true;
	for(auto [v, w] : G[u]) {
		if(v == fa) continue;
		dfs1(v, u);
		sz[u] += sz[v], tmp[u] += tmp[v] + sz[v] * w;
	}
}
void dfs2(int u, int fa) {
	for(auto [v, w] : G[u]) {
		if(v == fa) continue;
		tmp[v] = tmp[u] + (sz[node[len]] - 2 * sz[v]) * w;
		g[node[len]] = min(g[node[len]], tmp[v]);
		dfs2(v, u);
	}
}
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m;
	for(int i = 1, u, v; i <= m; i ++) {
		LL w;
		cin >> u >> v >> w;
		G[u].emplace_back(v, w), G[v].emplace_back(u, w);
	}
	for(int i = 1; i <= n - m - 1; i ++) cin >> w[i];
	for(int i = 1; i <= n; i ++) {
		if(!vis[i]) {
			dfs1(i, -1);
			node[++ len] = i, g[i] = tmp[i];
			dfs2(i, -1);
		}
	}
	for(int i = 1; i <= n; i ++) (ans += tmp[i]) %= Mod;
	(ans *= 500000004) %= Mod;
	sort(w + 1, w + n - m);
	sort(node + 1, node + len + 1, [](auto x, auto y) {
		return sz[x] > sz[y];
	});
	u = {g[node[1]], sz[node[1]]};
	for(int i = 2; i <= len; i ++) {
		v = {g[node[i]], sz[node[i]]};
		(ans += (LL)u[0] * v[1] % Mod + (LL)u[1] * v[0] % Mod + (LL)u[1] * v[1] * w[i - 1] % Mod) %= Mod;
		(u[0] += (LL)v[0] + v[1] * w[i - 1] % Mod) %= Mod, (u[1] += v[1]) %= Mod;
	}
	cout << ans << '\n';
	return 0;
}
```
# [[ARC187A] Add and Swap](https://atcoder.jp/contests/arc187/tasks/arc187_a)
这道题的重点就是观察操作。
- 发现：当我们对于 $i$ 操作了 2 次以后，$a_i, a_{i + 1} \rightarrow a_i + k, a_{i + 1} + k$。

故，我们可以固定 $a_1$，然后对于 $2 \le i < n$ 的 $i$ 不断进行操作直到 $1 ~ n - 1$ 单调不降。

这个时候我们只需要考虑 $a_{n - 1}$ 和 $a_n$ 的大小关系即可。

1. $a_{n - 1} \le a_n$ 直接输出即可。
2. $a_{n - 1} > a_n$：考虑对 $n - 2$ 不断操作直到 $a_{n - 1} > a_n + k$，然后交换 $a_{n - 1}$ 和 $a_n$，最后再调整 $a_{n - 1}$ 和 $a_{n - 2}$ 的大小关系即可（不断操作 $n - 1$ 就可以让 $a_{n - 2} \le a_{n - 1}$）。

注意：n = 2 的时候特判就行了。

AC code:
```
#include <bits/stdc++.h>
#define mkp(a, b) make_pair(a, b)
using namespace std;
using LL = long long;
using ULL = unsigned long long;
using LD = long double;
const int N = 100;
int n, k, a[N];
vector<int> ans;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> k;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    if(n == 2) {
        if(a[2] >= a[1]) cout << "Yes\n0\n";
        else if(a[2] + k > a[1]) cout << "No\n";
        else cout << "Yes\n1\n1";
        return 0;
    }
    for(int i = 2; i <= n - 1; i ++) {
        while(a[i] < a[i - 1]) {
            a[i] += k, a[i + 1] += k;
            ans.emplace_back(i), ans.emplace_back(i);
        }
    }
    if(a[n - 1] > a[n]) {
        while(a[n - 1] < a[n] + k) {
            a[n - 2] += k, a[n - 1] += k;
            ans.emplace_back(n - 2), ans.emplace_back(n - 2);
        }
        swap(a[n - 1], a[n]), a[n - 1] += k;
        ans.emplace_back(n - 1);
        while(a[n - 2] > a[n - 1]) {
            a[n - 1] += k, a[n] += k;
            ans.emplace_back(n - 1), ans.emplace_back(n - 1);
        }
    }
    cout << "Yes\n" << ans.size() << '\n';
    for(int x : ans) cout << x << '\n';
    return 0;
}
/*

*/
```
# [[ARC187B] Sum of CC](https://atcoder.jp/contests/arc187/tasks/arc187_b)
这种题就是锻炼自己找性质的好题。

题目中给出的关键条件：若 $a_i \le a_j$ 则 $i$ 和 $j$ 连通，得出 $i ~ j$ 为一个连通块。  
证明：容证。

有这个性质以后，其实就是要找有多少种情况 $i$ 和 $i + 1$ 是分开的。  
- 这个东西的充要条件就是：$\min_{j = 1}^i > \max_{j = i + 1}^n$

那么考虑枚举在 $i$ 的时候左右的最大值和最小值取为 $j$ 的取值方案数，然后固定一侧找到另一侧合法的方案用乘法原理解决。

说到这里其实就已经解决了，注意在最后要加上一个 $cnt^m$，$cnt$ 为 -1 的个数。原因是之前求出的是断点的个数，连通块在每种情况下都要 +1。

- 注意 mod = 998244353，由于写成了 1e9 + 7 虚空调试 20min。

AC code:
```
#include <bits/stdc++.h>
#define mkp(a, b) make_pair(a, b)
using namespace std;
using LL = long long;
using ULL = unsigned long long;
using LD = long double;
const int N = 2e3 + 10, Mod = 998244353;
int n, m, b[N], pre[N], suf[N], lmin[N], rmax[N];
LL l[N], r[N], ans;
LL qmi(LL a, int n) {
    LL res = 1;
    for(; n; n >>= 1, a = a * a % Mod) if(n & 1) res = res * a % Mod;
    return res % Mod;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> b[i];
    lmin[0] = m;
    for(int i = 1; i <= n; i ++) {
        if(~b[i]) lmin[i] = min(lmin[i - 1], b[i]);
        else lmin[i] = lmin[i - 1];
    }
    for(int i = n; i; i --) {
        if(~b[i]) rmax[i] = max(rmax[i + 1], b[i]);
        else rmax[i] = rmax[i + 1];
    }
    for(int i = 1; i <= n; i ++) pre[i] = pre[i - 1] + !(~b[i]);
    for(int i = n; i; i --) suf[i] = suf[i + 1] + !(~b[i]);
    for(int i = 1; i <= n; i ++) {
        memset(l, 0, sizeof l), memset(r, 0, sizeof r);
        for(int j = 1; j <= lmin[i]; j ++) l[j] = qmi((LL)m - j + 1, pre[i]);
        for(int j = rmax[i + 1]; j <= m; j ++) r[j] = qmi((LL)j, suf[i + 1]);// 注意边界！！！
        for(int j = 2; j <= m; j ++) ans = (ans + l[j] * (r[j - 1] - r[j - 2]) % Mod) % Mod;// 由于 b[i] >= 1，所以左边的最小值至少都要是 2，右边的意思是恰好最大值是 j - 1 的情况，所以这里是在固定右边最大值
    }
    (ans += qmi(m, suf[1])) %= Mod;
    ans = (ans % Mod + Mod) % Mod;
    cout << ans << '\n';
    return 0;
}
/*

*/
```
# [[ZJOI2005] 沼泽鳄鱼](https://www.luogu.com.cn/problem/P2579)
本来想着补短一下的，结果写这个题先是矩阵乘法写了 8 次，又是题目没有给 M 的范围，一直提示 RE。

回归正题，显然的矩阵乘法，很通用的方法是：$G^x_{i, j}$ 表示 $i$ 走到 $j$ 用 $x$ 步能到达的方案数。

很自然地我们会去考虑一下 $0 ~ 11$ 时刻的方案数（将 2, 3, 4 每种的情况都可以考虑进去），那么用个 $vis_{x, j}$ 表示 $x$ 在 $j$ 时刻是否合法就能很快求出 12 个矩阵了。

最后就是用矩阵快速幂求出 $Ans^\frac{k}{12}$ 了，单独处理余数即可。

```
#include <bits/stdc++.h>
#define int long long
#define mkp(a, b) make_pair(a, b)
using namespace std;
using LL = long long;
using ULL = unsigned long long;
using LD = long double;
const int N = 55, MC = 5e5, Mod = 1e4; // MC 往死里开
int n, m, s, t, k, NFish;
bool vis[N][N];
array<int, 2> evs[MC];
struct Matrix{
	int mat[N][N];
	Matrix() {memset(mat, 0, sizeof(mat));}
	Matrix operator * (const Matrix &x) const{
		Matrix tmp;
		for(int i = 1; i <= n; i ++) 
			for(int j = 1; j <= n; j ++) 
				for(int k = 1; k <= n; k ++) 
					tmp.mat[i][j] = (tmp.mat[i][j] + mat[i][k] * x.mat[k][j]) % Mod;
		return tmp;
	}
} M[12];
Matrix qmi(Matrix a, int b) {
	Matrix res;
	for(int i = 1; i <= n; i ++) res.mat[i][i] = 1;
	for(; b; b >>= 1, a = a * a) if(b & 1) res = res * a;
	return res;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m >> s >> t >> k, s ++, t ++;
	for(int i = 1; i <= m; i ++) {
		cin >> evs[i][0] >> evs[i][1];
		evs[i][0] ++, evs[i][1] ++;
	}
	cin >> NFish;
	for(int i = 1, T, x; i <= NFish; i ++) {
		cin >> T;
		for(int j = 0; j < T; j ++) {
			cin >> x, x ++;
			for(int k = j; k < 12; k += T) {
				vis[x][k] = true;
			}
		}
	}
	for(int i = 1; i <= m; i ++) {
		for(int T = 0; T < 12; T ++) {
			if(!vis[evs[i][1]][T]) M[T].mat[evs[i][0]][evs[i][1]] = 1;
			if(!vis[evs[i][0]][T]) M[T].mat[evs[i][1]][evs[i][0]] = 1;
		}
	}
	Matrix Ans;
	for(int i = 1; i <= n; i ++) Ans.mat[i][i] = 1;
	for(int T = 1; T < 12; T ++) Ans = Ans * M[T];
	Ans = Ans * M[0]; // 矩阵没有交换律！！！
	Ans = qmi(Ans, k / 12);
	for(int T = 1; T <= k % 12; T ++) Ans = Ans * M[T];
	cout << Ans.mat[s][t] << '\n';
	return 0;
}
/*

*/
```
