# [A:S](http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3355&tid=A)
很显然要用 dp 来解决这种题。  
由于 $n \le 300$，考虑状态 $f_{i, j, k, 0 / 1 / 2}$ 表示已经装好了 $i$ 个 R，$j$ 个 G，$k$ 个 Y，并且当前最后一个的颜色是 R / G / Y。  
那么显然可以顺推下去，明显有一个性质就是离当前位置最近的一个想要的颜色球移过来一定是最优的，于是直接上一个二分即可。  
代码很好写，注意一下初始化即可。
AC code : 
```
#include <bits/stdc++.h>
#define mkp(a, b) make_pair(a, b)
using namespace std;
using LL = long long;
using ULL = unsigned long long;
using LD = long double;
const int N = 4e2 + 10;
int n, f[N][N][N][3], ans = 0x3f3f3f3f;
int R, G, Y;
string s;
vector<int> col[3];
map<char, int> mp;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> s, s = " " + s;
    mp['R'] = 0, mp['G'] = 1, mp['Y'] = 2;
    for(int i = 1; i <= n; i ++) {
        col[mp[s[i]]].emplace_back(i);
        R += s[i] == 'R', G += s[i] == 'G', Y += s[i] == 'Y';
    }
    memset(f, 0x3f, sizeof f);
    if(R > 0) f[1][0][0][0] = col[0][0] - 1;
    if(G > 0) f[0][1][0][1] = col[1][0] - 1;
    if(Y > 0) f[0][0][1][2] = col[2][0] - 1;
    for(int i = 0; i <= R; i ++)
        for(int j = 0; j <= G; j ++)
            for(int k = 0; k <= Y; k ++)
                if(i || j || k)
                    for(int lst : {0, 1, 2})
                        if(f[i][j][k][lst] != 0x3f3f3f3f)
                            for(int nxt : {0, 1, 2})
                                if(lst != nxt) {
                                    int ni = i, nj = j, nk = k, idx;
                                    if(!nxt && i < R) ni ++, idx = i;
                                    else if(nxt == 1 && j < G) nj ++, idx = j;
                                    else if(nxt == 2 && k < Y) nk ++, idx = k;
                                    else continue;
                                    int tot = (lower_bound(col[0].begin(), col[0].begin() + i, col[nxt][idx]) - col[0].begin()) + (lower_bound(col[1].begin(), col[1].begin() + j, col[nxt][idx]) - col[1].begin()) + (lower_bound(col[2].begin(), col[2].begin() + k, col[nxt][idx]) - col[2].begin());
                                    f[ni][nj][nk][nxt] = min(f[ni][nj][nk][nxt], f[i][j][k][lst] + (col[nxt][idx] - 1) - tot);
                                }
    // cout << f[1][0][0][0] << '\n';
    for(int lst : {0, 1, 2}) ans = min(ans, f[R][G][Y][lst]);
    cout << (ans >= 0x3f3f3f3f ? -1 : ans) << '\n';
    return 0;
}
```
